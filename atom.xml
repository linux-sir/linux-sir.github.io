<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宁静致远</title>
  <subtitle>致力于构建自己的小宇宙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linuxsir.top/"/>
  <updated>2017-04-06T13:06:05.267Z</updated>
  <id>http://linuxsir.top/</id>
  
  <author>
    <name>Linuxsir</name>
    <email>linux.sir@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统的救生工具--SysRq键</title>
    <link href="http://linuxsir.top/2016/07/06/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%91%E7%94%9F%E5%B7%A5%E5%85%B7-SysRq%E9%94%AE/"/>
    <id>http://linuxsir.top/2016/07/06/Linux系统的救生工具-SysRq键/</id>
    <published>2016-07-06T12:41:11.000Z</published>
    <updated>2017-04-06T13:06:05.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向的读者"><a href="#面向的读者" class="headerlink" title="面向的读者"></a>面向的读者</h1><p>此文面向基于Linux平台的开发人员，全面了解SysRq的特殊作用及应用场景，例如，在系统卡死之时，能试着用sysrq键来救场。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然Linux以稳定而雄居服务器市场，但对于不断发现的Linux来说，难免还会出现卡死或死机的囧态，在这个危机时刻，使用一般的指令大法已经不管用了，因为它已经不听指令了（你通过Shell已经没有能力给它发送指令了），此时，就需要sysrq魔法键来救场了。</p>
<p>SysRq更像系统的救生工具，在危难时刻，通过它能保存现场数据，做一些必要的保护措施等，便于下一次更好地”重生”。</p>
<h1 id="SysRq的开关配置"><a href="#SysRq的开关配置" class="headerlink" title="SysRq的开关配置"></a>SysRq的开关配置</h1><p>SysRq 的开关共有两部分，一个是在内核配置中，另一个就是用户空间配置文件的设置</p>
<h2 id="1-让内核支持"><a href="#1-让内核支持" class="headerlink" title="1.让内核支持"></a>1.让内核支持</h2><p>此功能毕竟是在”最危难的”时刻，为sysrq开通”特殊通道”,让内核能按指令做一些必要的动作，如保存缓存中的数据，以确保数据的一致性，这个对于文件系统操作来说非常重要，特别是对于数据中心服务器来说。</p>
<h3 id="打开内核配置项"><a href="#打开内核配置项" class="headerlink" title="打开内核配置项"></a>打开内核配置项</h3><blockquote>
<p>CONFIG_MAGIC_SYSRQ=y</p>
</blockquote>
<p>可以通过下面命令来查看当前系统是否打开此功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep “ CONFIG_MAGIC_SYSRQ ” /boot/config-`uname – r`</div></pre></td></tr></table></figure>
<p>注：</p>
<blockquote>
<p>此配置项是在内核生成之初就需要设置好，才能使内核支持此特性。如同提前给内核打好招呼了。<br>当今绝大多数发行版均默认已经启用。</p>
</blockquote>
<h2 id="2-系统中开关"><a href="#2-系统中开关" class="headerlink" title="2.系统中开关"></a>2.系统中开关</h2><p>内核为用户空间提供了此项功能的配置项，对应的文件是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/proc/sys/kernel/sysrq</div></pre></td></tr></table></figure>
<p>一般通过直接修改此文件内容即可，在CentOS系统上，还可以通过sysctl命令来指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># sysctl -w kernel.sysrq=1 </div><div class="line"> kernel.sysrq = 1 </div><div class="line"> # cat /proc/sys/kernel/sysrq </div><div class="line"> 1</div></pre></td></tr></table></figure>
<p>注：</p>
<blockquote>
<p>上面指令只对当前终端环境有效，若需要在重启后仍有效，就需要将” kernel.sysrq = 1 ”设置到 /etc/sysctl.conf 中</p>
</blockquote>
<p>该文件内容最典型的值是0和1，0代表禁用此功能，1代表启用此功能，且接受所有sysrq指令，其不同的功能对应的值如下：</p>
<ul>
<li>2 - enable control of console logging level</li>
<li>4 - enable control of keyboard (SAK, unraw)</li>
<li>8 - enable debugging dumps of processes etc.</li>
<li>16 - enable sync command</li>
<li>32 - enable remount read-only</li>
<li>64 - enable signalling of processes (term, kill, oom-kill)</li>
<li>128 - allow reboot/poweroff</li>
<li>256 - allow nicing of all RT tasks</li>
</ul>
<p>同时，此文件也接受其它值，即代表只启用部分功能，并以几项指令和的形式设置此文件内容。例如：</p>
<p>在CentOS 7 上执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /proc/sys/kernel/sysrq </div><div class="line">16</div></pre></td></tr></table></figure>
<p>则说明在此系统上只启用了sync command功能</p>
<p>在Ubuntu版本上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /proc/sys/kernel/sysrq </div><div class="line">176</div></pre></td></tr></table></figure></p>
<p>176则说明启用了下面几项功能：</p>
<ul>
<li>128 - allow reboot/poweroff</li>
<li>32 - enable remount read-only</li>
<li>16 - enable sync command</li>
</ul>
<h1 id="SysRq的指令"><a href="#SysRq的指令" class="headerlink" title="SysRq的指令"></a>SysRq的指令</h1><p>sysrq不仅仅是用来保存现场或安全重启机器用的，其功能也很强大的，例如：</p>
<ul>
<li><p>‘b’     - Will immediately reboot the system without syncing or unmounting  your disks.</p>
</li>
<li><p>‘c’    - Will perform a system crash by a NULL pointer dereference. A crashdump will be taken if configured.</p>
</li>
<li><p>‘d’    - Shows all locks that are held.</p>
</li>
<li><p>‘e’     - Send a SIGTERM to all processes, except for init.</p>
</li>
<li><p>‘f’    - Will call oom_kill to kill a memory hog process.</p>
</li>
<li><p>‘g’    - Used by kgdb (kernel debugger)</p>
</li>
<li><p>‘h’     - Will display help (actually any other key than those listed  here will display help. but ‘h’ is easy to remember :-)</p>
</li>
<li><p>‘i’     - Send a SIGKILL to all processes, except for init.</p>
</li>
<li><p>‘j’     - Forcibly “Just thaw it” - filesystems frozen by the FIFREEZE ioctl.</p>
</li>
<li><p>‘k’     - Secure Access Key (SAK) Kills all programs on the current virtual  console. NOTE: See important comments below in SAK section.</p>
</li>
<li><p>‘l’     - Shows a stack backtrace for all active CPUs.</p>
</li>
<li><p>‘m’     - Will dump current memory info to your console.</p>
</li>
<li><p>‘n’    - Used to make RT tasks nice-able</p>
</li>
<li><p>‘o’     - Will shut your system off (if configured and supported).</p>
</li>
<li><p>‘p’     - Will dump the current registers and flags to your console.</p>
</li>
<li><p>‘q’     - Will dump per CPU lists of all armed hrtimers (but NOT regular timer_list timers) and detailed information about all clockevent devices.</p>
</li>
<li><p>‘r’     - Turns off keyboard raw mode and sets it to XLATE.</p>
</li>
<li><p>‘s’     - Will attempt to sync all mounted filesystems.</p>
</li>
<li><p>‘t’     - Will dump a list of current tasks and their information to your console.</p>
</li>
<li><p>‘u’     - Will attempt to remount all mounted filesystems read-only.</p>
</li>
<li><p>‘v’    - Forcefully restores framebuffer console</p>
</li>
<li><p>‘v’    - Causes ETM buffer dump [ARM-specific]</p>
</li>
<li><p>‘w’    - Dumps tasks that are in uninterruptable (blocked) state.</p>
</li>
<li><p>‘x’    - Used by xmon interface on ppc/powerpc platforms. Show global PMU Registers on sparc64.</p>
</li>
<li><p>‘y’    - Show global CPU Registers [SPARC-64 specific]</p>
</li>
<li><p>‘z’    - Dump the ftrace buffer</p>
</li>
<li><p>‘0’-‘9’ - Sets the console log level, controlling which kernel messages  will be printed to your console. (‘0’, for example would make it so that only emergency messages like PANICs or OOPSes would  make it to your console.)</p>
</li>
</ul>
<h1 id="SysRq的使用"><a href="#SysRq的使用" class="headerlink" title="SysRq的使用"></a>SysRq的使用</h1><h2 id="SysRq指令的执行"><a href="#SysRq指令的执行" class="headerlink" title="SysRq指令的执行"></a>SysRq指令的执行</h2><h3 id="第一种方式：键盘发送指令"><a href="#第一种方式：键盘发送指令" class="headerlink" title="第一种方式：键盘发送指令"></a>第一种方式：键盘发送指令</h3><p>使用SysRq的组合键是Alt + SysRq键（其中SysRq键一般是与PrintScreen是同一个键），同时按下这两个键，然后再按指令键（参见上面）即可。<br>注：</p>
<blockquote>
<p>通过键盘发送指令的好处就是在系统失去响应时，键盘是可以直接使用的。<br>在不同键盘上SysRq的标识可能稍有不同，主要有下图所示的样子<br><img src="http://on44nkxjb.bkt.clouddn.com/17-4-6/75452652-file_1491483499178_bec4.jpg" alt="image"></p>
</blockquote>
<h3 id="第二种方式：通过写入-etc-sysrq-trigger文件"><a href="#第二种方式：通过写入-etc-sysrq-trigger文件" class="headerlink" title="第二种方式：通过写入/etc/sysrq-trigger文件"></a>第二种方式：通过写入/etc/sysrq-trigger文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;b&apos; &gt; /etc/sysrq-trigger</div></pre></td></tr></table></figure>
<p>注：</p>
<blockquote>
<p>此种方式前提是还可以使用Shell，一般是图形界面失去响应，但可以SSH登录，使用Shell将指令写到sysrq-trigger里</p>
</blockquote>
<h1 id="SysRq的原理"><a href="#SysRq的原理" class="headerlink" title="SysRq的原理"></a>SysRq的原理</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p> Sysrq实现的基本原理为：在键盘或串口驱动中(如果是/proc接口方式，则直接定义/proc的相关写入接口即可)，对按键进行判断过滤，然后根据不同的按键进行相应的处理。普通键盘和串口的流程不尽相同，主要差别在键盘和串口驱动的具体实现上，总体流程一致。</p>
<p>对于普通键盘来说 ，其底层的处理(从硬件中断到键盘驱动)过程依赖于内核中的输入(input)子系统。键盘处理的大致流程如下：<br>    1）键盘中断调用中断服务程序<br>    2）键盘中断服务程序调用输入子系统<br>    3）输入子系统调用键盘设备对应的键盘事件处理器<br>    4）键盘事件处理器完成键码的转换分类工作，根据按键类型的不同，执行不同的操作。对于输入类按键，先将按键值存放到临时缓冲区，激活临时缓冲区的工作队列，然后结束。对于控制类按键，激活对应此次控制操作的工作队列，然后结束。<br>    5）系统在适当的时机调度工作队列执行，完成剩下的操作<br>    而Sysrq魔术键的处理比较特殊，在内核主分支的代码中，在上述步骤4中的键盘事件处理器中进行相应的处理，不依赖于工作队列，相当于直接在硬件中断中处理。而在3.10内核版本的分支代码中，处理流程不太一样，其合入了相应的补丁，使sysrq的处理剥离出来，放在input子系统进行处理，而脱离了键盘事件的处理流程，其还是在中断上下文中处理的，不依赖于工作队列等。主要是通过注册input_handler实现，具体见后面的代码分析。<br>    另一方面，对于串口设备来说，其sysrq的处理流程根据各串口驱动的实现而稍有不同，但基本都是直接在硬件中断中直接处理的。<br>    所以，总的来说，sysrq魔术键基本都在中断上下文中处理，优先级很高，能在关键时刻发挥重要作用。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p> Sysrq功能使用结构体sysrq_key_op定义了一个键盘键码所对应的行为，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct sysrq_key_op &#123;</div><div class="line">    void (*handler)(int);</div><div class="line">    char *help_msg;</div><div class="line">    char *action_msg;</div><div class="line">    int enable_mask;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注：</p>
<blockquote>
<ul>
<li>handler表示相应键码所对应的处理函数；</li>
<li>action_msg是执行处理函数前打印的信息；</li>
<li>help_msg指相应键码的帮助信息；</li>
<li>enable_mask指该功能是否打开，仅限于键盘输入方式。</li>
</ul>
</blockquote>
<p> 另外，sysrq还定义了一个静态全局数组sysrq_key_table，共有36个元素，其中0～9用于命令字0~9，10到36用于命令字a~z。当从/proc/得到输入的命令字后，可以根据这个规则计算出他在sysrq_key_table中的index，然后判断对应handler是否为空，如果不为空的话，则调用handler函数处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">static struct sysrq_key_op *sysrq_key_table[36] = &#123;</div><div class="line">    &amp;sysrq_loglevel_op,        /* 0 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 1 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 2 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 3 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 4 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 5 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 6 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 7 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 8 */</div><div class="line">    &amp;sysrq_loglevel_op,        /* 9 */</div><div class="line">    /*</div><div class="line">     * a: Don‘t use for system provided sysrqs, it is handled specially on</div><div class="line">     * sparc and will never arrive.</div><div class="line">     */</div><div class="line">    NULL,                /* a */</div><div class="line">    &amp;sysrq_reboot_op,        /* b */</div><div class="line">    &amp;sysrq_crash_op,        /* c &amp; ibm_emac driver debug */</div><div class="line">    &amp;sysrq_showlocks_op,        /* d */</div><div class="line">    &amp;sysrq_term_op,            /* e */</div><div class="line">    &amp;sysrq_moom_op,            /* f */</div><div class="line">    /* g: May be registered for the kernel debugger */</div><div class="line">    NULL,                /* g */</div><div class="line">    NULL,                /* h - reserved for help */</div><div class="line">    &amp;sysrq_kill_op,            /* i */</div><div class="line">#ifdef CONFIG_BLOCK</div><div class="line">    &amp;sysrq_thaw_op,            /* j */</div><div class="line">#else</div><div class="line">    NULL,                /* j */</div><div class="line">#endif</div><div class="line">    &amp;sysrq_SAK_op,            /* k */</div><div class="line">#ifdef CONFIG_SMP</div><div class="line">    &amp;sysrq_showallcpus_op,        /* l */</div><div class="line">#else</div><div class="line">    NULL,                /* l */</div><div class="line">#endif</div><div class="line">    &amp;sysrq_showmem_op,        /* m */</div><div class="line">    &amp;sysrq_unrt_op,            /* n */</div><div class="line">    /* o: This will often be registered as ‘Off‘ at init time */</div><div class="line">    NULL,                /* o */</div><div class="line">    &amp;sysrq_showregs_op,        /* p */</div><div class="line">    &amp;sysrq_show_timers_op,        /* q */</div><div class="line">    &amp;sysrq_unraw_op,        /* r */</div><div class="line">    &amp;sysrq_sync_op,            /* s */</div><div class="line">    &amp;sysrq_showstate_op,        /* t */</div><div class="line">    &amp;sysrq_mountro_op,        /* u */</div><div class="line">    /* v: May be registered for frame buffer console restore */</div><div class="line">    NULL,                /* v */</div><div class="line">    &amp;sysrq_showstate_blocked_op,    /* w */</div><div class="line">    /* x: May be registered on ppc/powerpc for xmon */</div><div class="line">    /* x: May be registered on sparc64 for global PMU dump */</div><div class="line">    NULL,                /* x */</div><div class="line">    /* y: May be registered on sparc64 for global register dump */</div><div class="line">    NULL,                /* y */</div><div class="line">    &amp;sysrq_ftrace_dump_op,        /* z */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="相关处理过程"><a href="#相关处理过程" class="headerlink" title="相关处理过程"></a>相关处理过程</h3><p>如之前所说，3.10版本内核代码中使用了input_handler来实现Sysrq魔术键的单独处理。</p>
<h4 id="相应的input-handler定义："><a href="#相应的input-handler定义：" class="headerlink" title="相应的input_handler定义："></a>相应的input_handler定义：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static struct input_handler sysrq_handler = &#123;</div><div class="line">    .filter        = sysrq_filter,/*相应的filter处理函数，在input子系统中调用，其中调用了Sysrq的处理函数*/</div><div class="line">    .connect    = sysrq_connect,</div><div class="line">    .disconnect    = sysrq_disconnect,</div><div class="line">    .name        = “sysrq”,</div><div class="line">    .id_table    = sysrq_ids,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="注册input-handler"><a href="#注册input-handler" class="headerlink" title="注册input_handler"></a>注册input_handler</h4><p>函数调用流程：sysrq_init()–&gt;sysrq_register_handler()–&gt;input_register_handler()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static int __init sysrq_init(void)</div><div class="line">&#123;</div><div class="line"> sysrq_init_procfs();</div><div class="line"> if (sysrq_on())</div><div class="line">  sysrq_register_handler();</div><div class="line"> return 0;</div><div class="line">&#125;</div><div class="line">static inline void sysrq_register_handler(void)</div><div class="line">&#123;</div><div class="line"> unsigned short key;</div><div class="line"> int error;</div><div class="line"> int i;</div><div class="line"> for (i = 0; i &lt; ARRAY_SIZE(sysrq_reset_seq); i++) &#123;</div><div class="line">  key = platform_sysrq_reset_seq[i];</div><div class="line">  if (key == KEY_RESERVED || key &gt; KEY_MAX)</div><div class="line">   break;</div><div class="line">  sysrq_reset_seq[sysrq_reset_seq_len++] = key;</div><div class="line"> &#125;</div><div class="line"> error = input_register_handler(&amp;sysrq_handler);</div><div class="line"> if (error)</div><div class="line">  pr_err(“Failed to register input handler, error %d”, error);</div><div class="line"> else</div><div class="line">  sysrq_handler_registered = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Sysrq魔术键处理代码流程："><a href="#Sysrq魔术键处理代码流程：" class="headerlink" title="Sysrq魔术键处理代码流程："></a>Sysrq魔术键处理代码流程：</h4><p>atkbd_interrupt()  //键盘中断ISR<br>    input_event() //输入子系统相关处理<br>        input_handle_event()<br>            input_pass_values()<br>                input_to_handler()<br>                    handler-&gt;filter() //sysrq预先注册好的handler(sysrq_handler)的filter接口(sysrq_filter)<br>                        sysrq_filter()<br>                            sysrq_handle_keypress()<br>                                __handle_sysrq()  //sysrq魔术键具体处理 </p>
<p>最终在__handle_sysrq()函数中完成Sysrq魔术键的具体处理。</p>
<h4 id="键盘其它按键的处理"><a href="#键盘其它按键的处理" class="headerlink" title="键盘其它按键的处理"></a>键盘其它按键的处理</h4><p>键盘其它按键的处理也是通过注册相应的input_handler(kbd_handler)来实现的，相应的event接口kbd_event()也在input子系统中调用：<br>/<em>键盘按键相应的input_handler</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static struct input_handler kbd_handler = &#123;</div><div class="line">    .event        = kbd_event,</div><div class="line">    .match        = kbd_match,</div><div class="line">    .connect    = kbd_connect,</div><div class="line">    .disconnect    = kbd_disconnect,</div><div class="line">    .start        = kbd_start,</div><div class="line">    .name        = “kbd”,</div><div class="line">    .id_table    = kbd_ids,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>kbd_handler注册：kbd_init()–&gt;input_register_handler()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int __init kbd_init(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    int error;</div><div class="line">    for (i = 0; i &lt; MAX_NR_CONSOLES; i++) &#123;</div><div class="line">        kbd_table[i].ledflagstate = kbd_defleds();</div><div class="line">        kbd_table[i].default_ledflagstate = kbd_defleds();</div><div class="line">        kbd_table[i].ledmode = LED_SHOW_FLAGS;</div><div class="line">        kbd_table[i].lockstate = KBD_DEFLOCK;</div><div class="line">        kbd_table[i].slockstate = 0;</div><div class="line">        kbd_table[i].modeflags = KBD_DEFMODE;</div><div class="line">        kbd_table[i].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;</div><div class="line">    &#125;</div><div class="line">    error = input_register_handler(&amp;kbd_handler);</div><div class="line">    if (error)</div><div class="line">        return error;</div><div class="line">    tasklet_enable(&amp;keyboard_tasklet);</div><div class="line">    tasklet_schedule(&amp;keyboard_tasklet);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>键盘其它按键的处理代码流程：<br>atkbd_interrupt()  //键盘中断ISR<br> input_event() //输入子系统相关处理<br> input_handle_event()<br> input_pass_values()<br> input_to_handler()<br> handler-&gt;events()  //键盘初始化是预先注册好的handler(kbd_handler)的event接口（kbd_event)<br> kbd_event()<br>   kbd_keycode()<br>   put_queue()<br>tty_insert_flip_char()  //将键盘键值对应的编码数据写入缓冲区<br>  tty_schedule_flip()  //激活工作队列处理，处理函数为flush_to_ldisc</p>
<p>最终在kbd_keycode()函数进行相应的键码处理，主要完成键码的转换分类工作，根据按键类型的不同，执行不同的操作。对于输入类按键，先将按键值存放到临时缓冲区，激活临时缓冲区的工作队列，然后结束。对于控制类按键，激活对应此次控制操作 的工作队列，然后结束。</p>
<p>通过/proc接口触发Sysrq魔术键的主要函数流程(write_sysrq_trigger()为/proc/sysrq-trigger接口的write接口)：  </p>
<p>write_sysrq_trigger()<br>    __handle_sysrq()</p>
<h3 id="串口驱动-以8250串口为例-中对Sysrq魔术键的支持："><a href="#串口驱动-以8250串口为例-中对Sysrq魔术键的支持：" class="headerlink" title="串口驱动(以8250串口为例)中对Sysrq魔术键的支持："></a>串口驱动(以8250串口为例)中对Sysrq魔术键的支持：</h3><p>按照sysrq的设计，通过标准串口链接，按下break键后5秒内，再按住command字符，会触发command对应的sysrq流程。<br>相关的处理流程如下(从串口驱动的接收函数serial8250_rx_chars()开始，此函数在中断上下文中执行):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">serial8250_rx_chars()</div><div class="line">     /*</div><div class="line">      * 判断是否按下了break键，用于判断Sysrq。当按住break键时，在uart_handle_break中判断port-&gt;sysrq是否为0，如果为0，</div><div class="line">      * 则将port-&gt;sysrq置为5秒后的jiffies数。</div><div class="line">      */</div><div class="line">    uart_handle_break()</div><div class="line">        /*</div><div class="line">         * 对于每一个接收的字符，都会调用uart_handle_sysrq_char。如果当前jiffies数值比port-&gt;sysrq小，</div><div class="line">         * 则说明当前字符是在按住了break后5秒内输入的，因此调用handle_sysrq处理该命令。</div><div class="line">         */</div><div class="line">        uart_handle_sysrq_char()</div></pre></td></tr></table></figure>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>SysRq键可以应对下面几种情况：</p>
<ul>
<li>使用SSH登录没有响应</li>
<li>用户界面卡死</li>
<li>系统挂死（调度异常，负荷过重，死锁等）</li>
</ul>
<p>此种情况下，就可以试着通过SysRq键来对系统进行必要的抢救。</p>
<h3 id="典型场景1"><a href="#典型场景1" class="headerlink" title="典型场景1"></a>典型场景1</h3><p>系统进入了挂死状态(如调度出现异常、或系统负荷过重），但仍能响应中断，此时可以通过Sysrq魔术键(c)手工触发panic，结合kdump，就能收集到vmcore信息，用于问题的后续分析定位，非常有用。</p>
<h3 id="典型场景2"><a href="#典型场景2" class="headerlink" title="典型场景2"></a>典型场景2</h3><p>当系统中某进程出现挂死(可能是D状态，或是死锁)，此时需要确认该进程具体挂在什么地方，可以使用Sysrq魔术键(t)打印出系统中所有进程的堆栈信息。</p>
<h3 id="典型场景3"><a href="#典型场景3" class="headerlink" title="典型场景3"></a>典型场景3</h3><p>当系统出现反应迟钝、交互困难时，难以通过shell或终端交互获取到有用信息，此时可以使用Sysrq魔术键(m,p)打印出系统中内存使用的详细信息和CPU运行上下文信息等。</p>
<p>参考：</p>
<blockquote>
<p><a href="http://www.linuxdiyf.com/linux/6210.html" target="_blank" rel="external">http://www.linuxdiyf.com/linux/6210.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/</a><br><a href="http://www.cnblogs.com/eksay/p/sysrq_linux.html" target="_blank" rel="external">http://www.cnblogs.com/eksay/p/sysrq_linux.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向的读者&quot;&gt;&lt;a href=&quot;#面向的读者&quot; class=&quot;headerlink&quot; title=&quot;面向的读者&quot;&gt;&lt;/a&gt;面向的读者&lt;/h1&gt;&lt;p&gt;此文面向基于Linux平台的开发人员，全面了解SysRq的特殊作用及应用场景，例如，在系统卡死之时，能试着用sysr
    
    </summary>
    
      <category term="调试工具" scheme="http://linuxsir.top/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="SysRq" scheme="http://linuxsir.top/tags/SysRq/"/>
    
      <category term="Linux内核" scheme="http://linuxsir.top/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核状态监控机制---核心转储</title>
    <link href="http://linuxsir.top/2016/05/05/Linux%E5%86%85%E6%A0%B8%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7%E6%9C%BA%E5%88%B6-%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8/"/>
    <id>http://linuxsir.top/2016/05/05/Linux内核状态监控机制-核心转储/</id>
    <published>2016-05-05T13:54:54.000Z</published>
    <updated>2017-04-05T14:01:31.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向的读者"><a href="#面向的读者" class="headerlink" title="面向的读者"></a>面向的读者</h1><p>此文章面向基于Linux平台的开发人员，特别是内核开发。通过此文章可以全面理解Core Dump机制及应用，帮助大家解决实际中遇到的疑难问题。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过多年的开源运动，众多的业界精英通力合作，Linux内核已经变得异常复杂，在运行状态的内核更是“深不可测”，众多进程运行过程中里面充满了竞争、协作、中断等不可预料的过程，面对如此繁杂的场景，若想对其中一两个进程进行普通形式的调试（如单步调试），则更是难上加难。<br>对于开发者而言，内核发生错误，就不应该继续运行，而应该马上停止，以便将问题及时暴露出来，以免发生更严重的后果。内核发生错误就让内核崩溃，机器重启等，但由于动态存储器的电气特性，重启机器后，数据就会丢失，发生错误的现场就会遭到破坏。为了解决这种难题，及时保存“事故现场”，提出了核心转储（Core Dump）机制。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core 就是沿用的是早期电脑磁芯内存中的表达。仔细查core过程中，还发现这个词还有一些故事。<br>在半导体作为电脑内存材料之前，电脑内存使用的是 磁芯内存（Magnetic Core Memory），是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今 ，半导体工业澎勃发展，已经没有人用 core memory 了，不过，在许多情况下， 人们还是把记忆体叫作 core 。 </p>
<p>Core Dump 中的 Core 沿用了磁芯内存的 Core 表达。图为磁芯内存的一个单元，来自 Wikipedia.<br><img src="http://on44nkxjb.bkt.clouddn.com/17-4-5/94108072-file_1491385350572_1144e.jpg" alt="image"></p>
<h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><p>Dump 指的是拷贝一种存储介质中的部分内容到另一个存储介质，或者将内容打印、显示或者其它输出设备。dump 出来的内容是格式化的，可以使用一些工具来解析它。</p>
<h2 id="Core-Dump"><a href="#Core-Dump" class="headerlink" title="Core Dump"></a>Core Dump</h2><p>现代操作系统中，用 Core Dump 表示当程序异常终止或崩溃或收到某些信号时，将进程此时的运行状态数据（包括内存，寄存器中的内容）拷贝到磁盘文件中存储，以文件形式存在，以方便编程人员调试。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>在进程异常时触发</li>
<li>保存进程的运行状态，便于事后分析还原现场，进一步找到问题</li>
<li>核心转储机制可以灵活地满足各种保存现场的需求</li>
<li>转储文件保存的仅仅是某一时刻的状态</li>
</ul>
<h3 id="core-dump-是一个监控机制"><a href="#core-dump-是一个监控机制" class="headerlink" title="core dump 是一个监控机制"></a>core dump 是一个监控机制</h3><p>更像是智慧城市中的摄像头，稍有不同的是Core Dump是在特定条件下触发，变得更智能，目的是一致的，还原现场，寻找线索，最终解决问题。</p>
<h1 id="Core-Dump实现原理"><a href="#Core-Dump实现原理" class="headerlink" title="Core Dump实现原理"></a>Core Dump实现原理</h1><h2 id="机制–-如何生成"><a href="#机制–-如何生成" class="headerlink" title="机制– 如何生成"></a>机制– 如何生成</h2><p>Core Dump得以实现要归功于信号处理机制，借助特定的信号，触发转储过程。</p>
<p>生成Core Dump文件本质就是<br>将运行状态的数据（内存数据，寄存器等）输出到文件中。</p>
<h2 id="策略–-何时生成"><a href="#策略–-何时生成" class="headerlink" title="策略– 何时生成"></a>策略– 何时生成</h2><p>有了上述机制，就可以针对特定信号，即需要生成Core Dump的特殊时刻进行处理。</p>
<h3 id="默认处理方式为Core-Dump的信号"><a href="#默认处理方式为Core-Dump的信号" class="headerlink" title="默认处理方式为Core Dump的信号"></a>默认处理方式为Core Dump的信号</h3><table>
<thead>
<tr>
<th>Signal</th>
<th>Action</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGQUIT</td>
<td>Core</td>
<td>Quit from keyboard</td>
</tr>
<tr>
<td>SIGILL</td>
<td>Core</td>
<td>Illegal Instruction</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>Core</td>
<td>Abort signal from abort</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>Core</td>
<td>Invalid memory reference</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>Core</td>
<td>Trace/breakpoint trap</td>
</tr>
</tbody>
</table>
<p>注：</p>
<blockquote>
<p>详细的信号处理请参考<a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="external">这里</a></p>
</blockquote>
<h1 id="核心转储的目标"><a href="#核心转储的目标" class="headerlink" title="核心转储的目标"></a>核心转储的目标</h1><p>Core Dump的目标就是为了获取运行状态，便于事后分析。因为在现实中有很多实际情况并不是那么方便获取某时刻的运行环境，例如嵌入式设备中一个偶发问题的排查，按普通调试的方式，并不是最有效的了。</p>
<h1 id="核心转储基本操作"><a href="#核心转储基本操作" class="headerlink" title="核心转储基本操作"></a>核心转储基本操作</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查看当前Core-Dump功能状态"><a href="#查看当前Core-Dump功能状态" class="headerlink" title="查看当前Core Dump功能状态"></a>查看当前Core Dump功能状态</h3><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -c</div></pre></td></tr></table></figure>
<blockquote>
<p>若返回0，代表core dump 机制是关闭的。<br>若是其它值就代表此功能是开启的。</p>
</blockquote>
<h3 id="启用核心转储"><a href="#启用核心转储" class="headerlink" title="启用核心转储"></a>启用核心转储</h3><h4 id="临时开启"><a href="#临时开启" class="headerlink" title="临时开启"></a>临时开启</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -c unlimited</div></pre></td></tr></table></figure></p>
<p>注：</p>
<blockquote>
<p>1) 以上命令代表开启core dump功能，且不限制转储文件的大小。<br>2) 若需要限制转储文件的大小，就将unlimited换成要限制的大小（单位是blocks,即KB）<br>3) 此种方式只对当前的终端环境有效</p>
</blockquote>
<h4 id="永久开启"><a href="#永久开启" class="headerlink" title="永久开启"></a>永久开启</h4><p>修改文件 /etc/security/limits.conf文件 ：<br>添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># /etc/security/limits.conf</div><div class="line">#</div><div class="line">#Each line describes a limit for a user in the form:</div><div class="line">#</div><div class="line">#&lt;domain&gt;   &lt;type&gt;   &lt;item&gt;   &lt;value&gt;</div><div class="line">    *          soft     core   unlimited</div></pre></td></tr></table></figure>
<h3 id="在专用目录生成转储文件"><a href="#在专用目录生成转储文件" class="headerlink" title="在专用目录生成转储文件"></a>在专用目录生成转储文件</h3><p>1) 默认生成的 core 文件保存在可执行文件所在的目录下，文件名就为 core。</p>
<p>2) 通过修改 /proc/sys/kernel/core_uses_pid 文件可以让生成 core 文件名是否自动加上 pid 号。<br>例如 echo 1 &gt; /proc/sys/kernel/core_uses_pid ，生成的 core 文件名将会变成 core.pid，其中 pid 表示该进程的 PID。</p>
<p>3) 还可以通过修改 /proc/sys/kernel/core_pattern 来控制生成 core 文件保存的位置以及文件名格式。<br>例如可以用 echo “/tmp/corefile-%e-%p-%t” &gt; /proc/sys/kernel/core_pattern 设置生成的 core 文件保存在 “/tmp/corefile” 目录下，文件名格式为 “core-命令名-pid-时间戳</p>
<h3 id="通过信号触发core-dump过程"><a href="#通过信号触发core-dump过程" class="headerlink" title="通过信号触发core dump过程"></a>通过信号触发core dump过程</h3><h4 id="示例1：段错误触发"><a href="#示例1：段错误触发" class="headerlink" title="示例1：段错误触发"></a>示例1：段错误触发</h4><p>代码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int func(int *p)</div><div class="line">&#123;</div><div class="line">    int y = *p;</div><div class="line">    return y;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int *p = NULL;</div><div class="line">    return func(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：<br>1). 很明显，上述是典型的使用非法指针，此严重错误会触发core dump<br>2). 进程发生段错误其实就是非法使用内存，这时会收到SIGSEGV信号（segmentationviolation 段违例的缩写）</p>
<p>触发Core Dump：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@localhost dump_test]# gcc -o test test.c -g</div><div class="line">[root@localhost dump_test]# ls -l</div><div class="line">\u603b\u7528\u91cf 16</div><div class="line">-rwxr-xr-x. 1 root root 9656 4\u6708   5 19:28 test</div><div class="line">-rw-r--r--. 1 root root  124 4\u6708   5 19:28 test.c</div><div class="line">[root@localhost dump_test]# ls</div><div class="line">test  test.c</div><div class="line">[root@localhost dump_test]# ./test </div><div class="line">\u6bb5\u9519\u8bef(\u5410\u6838)</div><div class="line">[root@localhost dump_test]# ls</div><div class="line">core.29306  test  test.c</div></pre></td></tr></table></figure></p>
<p>可以看到默认情况下，在进程的当前目录下生成了转储文件core.29306 (其中29306是刚才进程的PID)。</p>
<p>注：常见引起段错误的非法操作有：</p>
<ul>
<li>数组越界访问</li>
<li>访问空指针</li>
<li>栈溢出</li>
<li>修改只读内存</li>
</ul>
<h4 id="示例2-：-使用其它信号触发"><a href="#示例2-：-使用其它信号触发" class="headerlink" title="示例2 ： 使用其它信号触发"></a>示例2 ： 使用其它信号触发</h4><p>通过ctrl + \ 组合键来终止一个进程，其实是发送SIGQUIT信号，此信号默认处理方式就是触发Core Dump</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost sig_test]# ls</div><div class="line">[root@localhost sig_test]# sleep 10</div><div class="line">^\\u9000\u51fa(\u5410\u6838)</div><div class="line">[root@localhost sig_test]# ls</div><div class="line">core.30778</div></pre></td></tr></table></figure>
<p>注： </p>
<blockquote>
<p>向一个进程发送一个信号，还可以通过kill命令，它甚至可以使一个正常的进程Down掉并触发Core Dump。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill -s SIGSEGV pid</div></pre></td></tr></table></figure>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="1-调试"><a href="#1-调试" class="headerlink" title="1.调试"></a>1.调试</h2><p>这里以上面示例1产生的转储文件为例，简单说明一下，如何用GDB调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[root@localhost dump_test]# gdb test core.29306 </div><div class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7</div><div class="line">Copyright (C) 2013 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="line">Reading symbols from /root/workspace/dump_test/test...done.</div><div class="line">[New LWP 29306]</div><div class="line">Core was generated by `./test&apos;.</div><div class="line">Program terminated with signal 11, Segmentation fault.</div><div class="line">#0  0x00000000004004f9 in func (p=0x0) at test.c:4</div><div class="line">4	    int y = *p;</div><div class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-157.el7.x86_64</div><div class="line">(gdb) where</div><div class="line">#0  0x00000000004004f9 in func (p=0x0) at test.c:4</div><div class="line">#1  0x000000000040051f in main () at test.c:10</div><div class="line">(gdb) info frame</div><div class="line">Stack level 0, frame at 0x7ffd8e052410:</div><div class="line"> rip = 0x4004f9 in func (test.c:4); saved rip 0x40051f</div><div class="line"> called by frame at 0x7ffd8e052430</div><div class="line"> source language c.</div><div class="line"> Arglist at 0x7ffd8e052400, args: p=0x0</div><div class="line"> Locals at 0x7ffd8e052400, Previous frame&apos;s sp is 0x7ffd8e052410</div><div class="line"> Saved registers:</div><div class="line">  rbp at 0x7ffd8e052400, rip at 0x7ffd8e052408</div><div class="line">(gdb) quit</div></pre></td></tr></table></figure>
<p>注：这里就可以使用GDB的命令来分析当时出错的事故现场了。</p>
<h2 id="2-排查段错误的神器"><a href="#2-排查段错误的神器" class="headerlink" title="2.排查段错误的神器"></a>2.排查段错误的神器</h2><p>段错误是最常见的软件错误，具体实例参见上面调试实例。</p>
<h2 id="3-内存取证"><a href="#3-内存取证" class="headerlink" title="3.内存取证"></a>3.内存取证</h2><p>计算机取证是一个重要的应用领域，相关的工具也有很多。详细可参考<a href="https://www.ibm.com/developerworks/cn/linux/1511_cyq_tool/" target="_blank" rel="external">这里</a></p>
<p>Core Dump的本质是获取内存和寄存器状态数据，最常见的目的就是调试程序，排查问题，有时并不是因错误引起，而是因内存取证的原因，主动触发Core Dump 。</p>
<p>参考：</p>
<blockquote>
<p><a href="http://blog.csdn.net/hust_wusen/article/details/8776116" target="_blank" rel="external">http://blog.csdn.net/hust_wusen/article/details/8776116</a><br><a href="http://www.cnblogs.com/hazir/p/linxu_core_dump.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/linxu_core_dump.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向的读者&quot;&gt;&lt;a href=&quot;#面向的读者&quot; class=&quot;headerlink&quot; title=&quot;面向的读者&quot;&gt;&lt;/a&gt;面向的读者&lt;/h1&gt;&lt;p&gt;此文章面向基于Linux平台的开发人员，特别是内核开发。通过此文章可以全面理解Core Dump机制及应用，帮助大家
    
    </summary>
    
      <category term="调试工具" scheme="http://linuxsir.top/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="核心转储" scheme="http://linuxsir.top/tags/%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8/"/>
    
      <category term="内核调试" scheme="http://linuxsir.top/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"/>
    
      <category term="Linux" scheme="http://linuxsir.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多角度看TCP/IP协议栈--时间角度</title>
    <link href="http://linuxsir.top/2016/03/23/%E5%A4%9A%E8%A7%92%E5%BA%A6%E7%9C%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88-%E6%97%B6%E9%97%B4%E8%A7%92%E5%BA%A6/"/>
    <id>http://linuxsir.top/2016/03/23/多角度看TCP-IP协议栈-时间角度/</id>
    <published>2016-03-23T11:51:17.000Z</published>
    <updated>2016-01-31T12:46:53.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;  读史可以明智，在这里，我们探讨一下TCP/IP协议栈的历史故事，可以让我们从时间的角度，通过了解过去，来理解其形成过程及美好未来。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="TCP-IP与OSI参考模型"><a href="#TCP-IP与OSI参考模型" class="headerlink" title="TCP/IP与OSI参考模型"></a>TCP/IP与OSI参考模型</h2><p>&ensp;&ensp;说到网络协议，第一个进入脑海的很可能就是OSI七层模型，它是理解网络层次的最常用的模型，当然TCP/IP协议栈是OSI从理论到实现的最成熟的现实版本。二者之间对应关系如下图所示：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/2017-03-23_201525.png" alt="image"></p>
<h2 id="子协议栈"><a href="#子协议栈" class="headerlink" title="子协议栈"></a>子协议栈</h2><p>表面上看TCP/IP看似只有两种协议，其实它的名字只是其中两大成员的名字，除了这两种协议之后，还有其它的成员，如：</p>
<p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/2017-03-23_202231.png" alt="image"></p>
<h1 id="TCP-IP的前世"><a href="#TCP-IP的前世" class="headerlink" title="TCP/IP的前世"></a>TCP/IP的前世</h1><h2 id="TCP-IP之父"><a href="#TCP-IP之父" class="headerlink" title="TCP/IP之父"></a>TCP/IP之父</h2><ol>
<li>于罗伯特·卡恩的介绍：<br>常称鲍勃·卡恩(Bob Kahn)，生于美国纽约州纽约市布鲁克林区，发明了TCP协议，并与文特·瑟夫一起发明了IP协议;这两个协议成为互联网存在基石。</li>
<li>文顿·瑟夫的介绍：<br>文顿·格雷·瑟夫(英语：Vinton Gray Cerf，1943年6月23日-)，昵称为文特·瑟夫(Vint Cerf )，生于美国康涅狄格州纽黑文，计算机科学家，因与罗伯特·卡恩设计了TCP/IP协议和互联网基础架构而被共同称为“互联网之父”。<br>文顿·瑟夫的履历：</li>
</ol>
<ul>
<li>生于1943年，童年时酷爱算术和科学，1965年在斯坦福大学获得了数学学士学位。</li>
<li>曾就职于IBM公司，1967年，考取了美国加州大学研究生院，取得计算机科学博士学位。</li>
<li>1972年-1976年，任教斯坦福大学，其间与罗伯特·卡恩一道领导TCP/IP协议的研发小组。</li>
<li>1997年12月，获得美国国家技术勋章 。</li>
<li>现任ICANN(互联网名字和号码分配机构)主席，兼任美国MCI公司技术战略高级副总裁。</li>
</ul>
<p>布什总统为罗伯特·卡恩(中者)和文特·瑟夫(左者)颁发勋章：</p>
<p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134015415002.jpg" alt="image"></p>
<p>注：1997年12月，布什总统为表彰罗伯特·卡恩和文特·瑟夫为互联网的建立和发展所做的贡献而给他俩都颁发的美国国家技术勋章。</p>
<p>罗伯特·卡恩(左者)与文特·瑟夫(右者)一起接受访谈：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134016851003.jpg" alt="image"></p>
<h2 id="见证互联网"><a href="#见证互联网" class="headerlink" title="见证互联网"></a>见证互联网</h2><p>1969年8月30日，由BBN公司制造的第一台“接口信息处理机”IMP1，在预定日期前2天运抵UCLA。美国加州大学洛杉矶分校(UCLA)计算机系教授、著名的网络先驱人物克兰罗克带着40多名工程技术人员和研究生进行安装和调试。10月初，第二台IMP2运到阿帕网试验的第二节点斯坦福研究院(SRI)。    </p>
<p>经过数百人一年多时间的紧张研究，阿帕网远程联网试验即将正式实施。<br>不久后，1969年11月，第三台IMP3抵达阿帕网第三节点——加州大学圣巴巴拉分校(UCSB);1969年12月，最后一台供试验的IMP4在阿帕网第四节点——犹他大学(Utah)安装成功，基本实现了罗伯茨规划的设计蓝图。于是，具有4个节点阿帕网(ARPANet)正式启用，人类社会从此跨进了网络时代。<br>BBN程序员团队合影：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134017452004.jpg" alt="image"></p>
<p>见证首次互联网连接实验的工作日志：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134017340005.jpg" alt="image"><br>当时IMP1与主机Sigma-7的连接现场：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134017385006.jpg" alt="image"></p>
<h2 id="原始的网络变成真正的”互联网”"><a href="#原始的网络变成真正的”互联网”" class="headerlink" title="原始的网络变成真正的”互联网”"></a>原始的网络变成真正的”互联网”</h2><h3 id="早期的网络并不实用"><a href="#早期的网络并不实用" class="headerlink" title="早期的网络并不实用"></a>早期的网络并不实用</h3><p>   把两台计算机连在一起，只是迈出了建立互联网的一小步。人们很快发现，如果要把更多的不同型号的计算机，通过不同规格的网络连接在一起，还要让它们能共享内容，就非得发明一套更先进的技术不可。<br>假如看到互联网发明之初的那股子混乱劲儿，熟练操作着智能手机、利用无线信号进行视频对话的现代人可能会觉得难以置信。阿帕网问世之后，美国军方很快采纳了这一技术，但是，接入网络的电脑越来越多，造成发送信息的计算机很难在庞杂的网络中定位目标计算机。并且，最初的网络缺少纠错功能，数据在传输过程中一旦出现错误，网络就可能停止运行。出错电脑增多，使得网络运行效率大打折扣。</p>
<h3 id="TCP-IP横空出世"><a href="#TCP-IP横空出世" class="headerlink" title="TCP/IP横空出世"></a>TCP/IP横空出世</h3><p>&ensp; 如今大名鼎鼎的两位科学家、TCP/IP协议的发明者——罗伯特·卡恩和文顿·瑟夫就是在这时开始了他们的重要工作。他们恐怕也是这一群拥有“互联网之父”头衔的科学家中知名度最高的。他们都获得过“计算机科学界的诺贝尔奖”——图灵奖，瑟夫还曾任谷歌公司的全球副总裁和首席互联网专家。<br>&ensp; 两位科学家首先着眼于给每台电脑都分配一个唯一的确定的地址，就像住宅的门牌号一样，有了它快递员才能把包裹准确投递到位——这就是IP。而TCP则负责监督传输过程，一出现问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。这套思想直接导致了一种新设备——路由器的出现。<br>&ensp; 在1973年问世并被持续不断改进的TCP/IP协议至今仍然是全球互联网得以稳定运作的保证。通过这项技术，两位科学家使信息传输的可靠性完全由主机设备保障，而与连接这些主机的网络硬件的材质与形态无关。人们评价说，TCP/IP技术将最终可以运行在“两个罐子和一根弦”上，甚至可以用信鸽来代替网络。<br>&ensp; 1974年，人们亲眼见证了TCP/IP协议的成功。在这场实验中，科学家将数据包在卫星网络和陆地电缆之间反复传输，贯穿欧洲和美国的电脑系统，全程9.4万公里，没有丢失一个数据位。同年，美国政府无条件公布了TCP/IP协议的核心技术，世界范围内的互联网浪潮随之兴起。</p>
<h3 id="感谢两位大师的分享精神"><a href="#感谢两位大师的分享精神" class="headerlink" title="感谢两位大师的分享精神"></a>感谢两位大师的分享精神</h3><p>假设：如果将TCP/IP申请专利，世界首富还会是盖茨吗?<br>“全世界已经有超过10亿人在使用互联网。” 文顿·瑟夫说，“坦率说，三十多年前研究TCP/IP的时候，我们没有想到这项技术会得到如此广泛的运用。”<br>“申请专利从实际的角度是行不通的，如果新技术不是无偿和免费的话，人们就会远离我们而去。” 文特·瑟夫坚持将今天互联网成功的原因之一归结于他和罗伯特·卡恩没有申请专利，把TCP/IP视为私有财产。<br>1973年，文特·瑟夫和罗伯特·卡恩在设计互联网的时候，做出一项重要决定，一定要让电脑和电脑之间的沟通敞开和透明;1975年，开始布设互联网的时候，两人一致决定要把这个礼物贡献给人们，让大家自由的分享。</p>
<h1 id="TCP-IP的今生"><a href="#TCP-IP的今生" class="headerlink" title="TCP/IP的今生"></a>TCP/IP的今生</h1><p>如今，TCP/IP协议让互联网越来越远，毫不夸张的说，没有这张“网”的世界将不能成为21世纪。“网”一直处于虑拟世界，看不见、摸不着，连接世界的互联网你有没有想过到底是什么样子的?一起来看看。<br>看起来是下面这个样子的(由Opte工程组绘制的互联网地图)，</p>
<h2 id="虚拟的互联网的样子"><a href="#虚拟的互联网的样子" class="headerlink" title="虚拟的互联网的样子"></a>虚拟的互联网的样子</h2><h3 id="1-2003年的“互联网”"><a href="#1-2003年的“互联网”" class="headerlink" title="1)2003年的“互联网”"></a>1)2003年的“互联网”</h3><p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134019554008.jpg" alt="image"></p>
<h3 id="2-2010年的“互联网”"><a href="#2-2010年的“互联网”" class="headerlink" title="2)2010年的“互联网”"></a>2)2010年的“互联网”</h3><p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134020722009.jpg" alt="image"></p>
<h3 id="3）2015年的“互联网”"><a href="#3）2015年的“互联网”" class="headerlink" title="3）2015年的“互联网”"></a>3）2015年的“互联网”</h3><p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134020813010.jpg" alt="image"></p>
<p>注：以上图片是基于真实的世界互联网真实路由节点绘制出来的，具体流程如下图所示：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134020212011.jpg" alt="image"></p>
<h2 id="TCP-IP改变了世界"><a href="#TCP-IP改变了世界" class="headerlink" title="TCP/IP改变了世界"></a>TCP/IP改变了世界</h2><h3 id="通过TCP-IP是如何缩短地球上人与人的距离"><a href="#通过TCP-IP是如何缩短地球上人与人的距离" class="headerlink" title="通过TCP/IP是如何缩短地球上人与人的距离?"></a>通过TCP/IP是如何缩短地球上人与人的距离?</h3><p>答案是通过各国铺设在海地的通讯光缆实现的。下面一起来看看截至2015年国与国之间通过海底光缆的“连接”情况。<br>2015年全球互联网跨国通信光缆的连接情况图：</p>
<p><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134021640012.jpg" alt="image"><br>2015年全球互联网跨国通信光缆的连接情况图(中国部分放大显示)：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134021441013.jpg" alt="image"><br>注：这张图里可以看到，中国的跨国海底光缆并不多，连接国外的网站延迟这么大也就是情理之中的事了。<br>一张更吊炸天的全球互联网跨国通信光缆的连接情况图(2015年版)：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134022844014.jpg" alt="image"><br>好吧，我要是麻花腾，也做一张类似的QQ、微信的连接情况，估计会有拿破仑征服欧洲那样的成就感。。。</p>
<h3 id="TCP-IP重新定义了国与国、人与人之间的距离单位"><a href="#TCP-IP重新定义了国与国、人与人之间的距离单位" class="headerlink" title="TCP/IP重新定义了国与国、人与人之间的距离单位"></a>TCP/IP重新定义了国与国、人与人之间的距离单位</h3><p>对于互联网世界来说，网络之间的距离可以用“网络延迟”来衡量(单位通常是毫秒)，从真实世界的角度讲，正是TCP/IP协议的威力，重新定义了国与国、人与人之间的距离单位，让“连接”变的没有距离感。<br>你可能会好奇，我们与世界各主要国家的通信延迟到底是多少呢?我们一起来看看下面几个图。<br>从香港发起的通信，与世界主要节点的延迟示意图：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134022239015.jpg" alt="image"><br>说明：香港到美国的延迟大约是150ms、到英国超过200ms。<br>从英国发起的通信，与世界主要节点的延迟示意图：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134022485016.jpg" alt="image"><br>说明：从英国到中国的延迟大约是200ms。<br>从美国发起的通信，与世界主要节点的延迟示意图：<br><img src="/2016/03/23/多角度看TCP-IP协议栈-时间角度/20160911134022361017.jpg" alt="image"><br>说明：从美国到中国的延迟大约是120ms、到日本约80ms(果然是盟友)。</p>
<h1 id="TCP-IP的未来"><a href="#TCP-IP的未来" class="headerlink" title="TCP/IP的未来"></a>TCP/IP的未来</h1><p>网络形态的变化越来越超乎人的想象，变化速度也越来越不能人太多的喘息时间，从网络到互联网，其中从PC端转移到移动端，再结合各种云端，演化出各种贴心的服务，如智能家居，物联网，机器人及人工智能等，在这个过程中，必然离不开TCP/IP的幕后英雄，同样，它也不断地面临各种新的挑战，不断进化自己，武装自己。</p>
<p>让我们一起见证TCP/IP的美好未来吧！</p>
<p>参考：</p>
<blockquote>
<p><a href="http://network.chinabyte.com/412/13889412.shtml" target="_blank" rel="external">http://network.chinabyte.com/412/13889412.shtml</a><br>《图解TCP/IP》第5版</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;ensp;  读史可以明智，在这里，我们探讨一下TCP/IP协议栈的历史故事，可以让我们从时间的角度，通过了解过去，来理解其形成过程及美好
    
    </summary>
    
      <category term="TCP/IP" scheme="http://linuxsir.top/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>程序跟踪器---strace</title>
    <link href="http://linuxsir.top/2016/03/01/%E7%A8%8B%E5%BA%8F%E8%B7%9F%E8%B8%AA%E5%99%A8-strace/"/>
    <id>http://linuxsir.top/2016/03/01/程序跟踪器-strace/</id>
    <published>2016-03-01T13:39:31.000Z</published>
    <updated>2017-04-01T23:09:43.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向的读者"><a href="#面向的读者" class="headerlink" title="面向的读者"></a>面向的读者</h1><p>此篇面向经常需要解决Linux平台上程序的疑难杂症的读者，通过此篇可以掌握strace的常见用法，全面了解strace的特点，以备不时之需。</p>
<h1 id="strace简介"><a href="#strace简介" class="headerlink" title="strace简介"></a>strace简介</h1><p>原装的介绍是“strace – trace system calls and signals”</p>
<h2 id="平凡的出身"><a href="#平凡的出身" class="headerlink" title="平凡的出身"></a>平凡的出身</h2><p>平凡是因为它在几乎所有的Linux发行版上可用。看似常见，但属于默默无闻的干将类型。</p>
<h2 id="功能强大"><a href="#功能强大" class="headerlink" title="功能强大"></a>功能强大</h2><p>可用来跟踪在部分程序，不论是已经在运行的，还是未运行的，对于只有二进制的运行程序也能轻松应对。<br>有以下几个特点：</p>
<ul>
<li>最大的特点就是无损跟踪，这里无损理解为不需要重新构建，不需要添加调试信息，不破坏目标程序。</li>
<li>面向系统调用的过程,即与内核交互的过程细节</li>
<li>可面对已经在运行的进程</li>
<li>可面对随时可以启动的进程</li>
<li>可面对无源代码的二进制程序</li>
</ul>
<p>注：strace虽然使用方便，但它也不是全能的，与GDB等专业调试器的定位不同。</p>
<h2 id="特异功能"><a href="#特异功能" class="headerlink" title="特异功能"></a>特异功能</h2><p>可以实时地查看程序运行过程中涉及的所有系统调用过程信息以及信号产生情况</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="完整的使用姿势："><a href="#完整的使用姿势：" class="headerlink" title="完整的使用姿势："></a>完整的使用姿势：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o /tmp/output.txt -T -tt -e trace=desc -s 12 -p 17129</div></pre></td></tr></table></figure>
<p>注：最完整的使用方式当然可以随时请教系统中最专业的绅士(man)</p>
<h2 id="strace反馈的结果"><a href="#strace反馈的结果" class="headerlink" title="strace反馈的结果"></a>strace反馈的结果</h2><h2 id="常用的使用方式："><a href="#常用的使用方式：" class="headerlink" title="常用的使用方式："></a>常用的使用方式：</h2><h3 id="1-寻找被读取的配置文件"><a href="#1-寻找被读取的配置文件" class="headerlink" title="1.寻找被读取的配置文件"></a>1.寻找被读取的配置文件</h3><p>例如，以安装一个deb包为例，使用strace可以看到它的执行后台的细节信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o dpkg.log dpkg -i soft_2.01-15_amd64.deb</div></pre></td></tr></table></figure>
<p>其中dpkg.log就是跟踪的日志，查看dpkg.log内容节选如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">execve(&quot;/usr/bin/dpkg&quot;, [&quot;dpkg&quot;, &quot;-i&quot;, &quot;soft_2.01-15_amd64.deb&quot;], [/* 51 vars */]) = 0</div><div class="line">brk(0)                                  = 0x82be75a000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7e98b5c2d000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">..........</div><div class="line">open(&quot;/etc/nsswitch.conf&quot;, O_RDONLY|O_CLOEXEC) = 9</div><div class="line">fstat(9, &#123;st_mode=S_IFREG|0644, st_size=475, ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7e98b5bfd000</div><div class="line">read(9, &quot;# /etc/nsswitch.conf\n#\n# Example&quot;..., 4096) = 475</div><div class="line">read(9, &quot;&quot;, 4096)                       = 0</div><div class="line">close(9)                                = 0</div></pre></td></tr></table></figure></p>
<p>从日志里就可以看到读过哪些文件，例如上面的/etc/nsswitch.conf文件。</p>
<h3 id="2-跟踪指定的系统调用"><a href="#2-跟踪指定的系统调用" class="headerlink" title="2.跟踪指定的系统调用"></a>2.跟踪指定的系统调用</h3><p>-e选项是专门用来指定跟踪的焦点，即某个系统调用，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o dpkg.log -e open dpkg -i soft_2.01-15_amd64.deb</div></pre></td></tr></table></figure>
<p>其中得到的日志内容里只有open系统调用相关的信息了，这里节选一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">open(&quot;/usr/lib/libnfsp.so&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libselinux.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libpcre.so.3&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libdl.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">open(&quot;/etc/dpkg/dpkg.cfg&quot;, O_RDONLY)    = 3</div><div class="line">open(&quot;/root/.dpkg.cfg&quot;, O_RDONLY)       = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/var/lib/dpkg/lock&quot;, O_RDWR|O_CREAT|O_TRUNC, 0660) = 3</div><div class="line">open(&quot;/usr/share/locale/locale.alias&quot;, O_RDONLY|O_CLOEXEC) = 4</div></pre></td></tr></table></figure>
<h3 id="3-跟踪正在运行的进程"><a href="#3-跟踪正在运行的进程" class="headerlink" title="3.跟踪正在运行的进程"></a>3.跟踪正在运行的进程</h3><p>通过-p选项来指定跟踪的目标，即一个正在运行的进程PID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -p $&#123;PID&#125;</div></pre></td></tr></table></figure></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# strace -p 2965</div><div class="line">Process 2965 attached</div><div class="line">ppoll([&#123;fd=5, events=POLLIN&#125;, &#123;fd=4, events=POLLIN&#125;, &#123;fd=28, events=POLLIN&#125;, &#123;fd=9, events=POLLIN&#125;, &#123;fd=24, events=POLLIN&#125;, &#123;fd=27, events=POLLIN&#125;, &#123;fd=23, events=POLLIN&#125;, &#123;fd=16, events=POLLIN&#125;, &#123;fd=19, events=POLLIN&#125;, &#123;fd=14, events=POLLIN|POLLERR|POLLHUP&#125;, &#123;fd=14, events=0&#125;, &#123;fd=13, events=POLLIN&#125;, &#123;fd=12, events=POLLIN&#125;, &#123;fd=7, events=POLLIN&#125;], 14, NULL, NULL, 8</div></pre></td></tr></table></figure>
<h3 id="4-strace的统计概要"><a href="#4-strace的统计概要" class="headerlink" title="4.strace的统计概要"></a>4.strace的统计概要</h3><p>一般情况下strace的输出显得杂乱无章的，为此，strace为大家提供了统计选项“-c”,通过此选项，可以看到系统调用的概要，执行时间，错误等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# strace -c ls</div><div class="line">anaconda-ks.cfg  gdm.log  initial-setup-ks.cfg	perl5  rpmbuild  software  test.py  work  \u516c\u5171	\u6a21\u677f  \u89c6\u9891  \u56fe\u7247  \u6587\u6863	\u4e0b\u8f7d  \u97f3\u4e50  \u684c\u9762</div><div class="line">% time     seconds  usecs/call     calls    errors syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line"> 28.75    0.000554         554         1           stat</div><div class="line"> 21.17    0.000408         204         2         1 access</div><div class="line"> 16.76    0.000323         162         2           statfs</div><div class="line"> 10.85    0.000209           7        28           mmap</div><div class="line">  9.03    0.000174          10        18           mprotect</div><div class="line">  7.27    0.000140          13        11           open</div><div class="line">  2.02    0.000039           5         8           read</div><div class="line">  1.40    0.000027           2        12           fstat</div><div class="line">  1.30    0.000025          25         1           execve</div><div class="line">  1.09    0.000021           2        14           close</div><div class="line">  0.21    0.000004           1         3           brk</div><div class="line">  0.16    0.000003           3         1           arch_prctl</div><div class="line">  0.00    0.000000           0         1           write</div><div class="line">  0.00    0.000000           0         2           munmap</div><div class="line">  0.00    0.000000           0         2           rt_sigaction</div><div class="line">  0.00    0.000000           0         1           rt_sigprocmask</div><div class="line">  0.00    0.000000           0         2           ioctl</div><div class="line">  0.00    0.000000           0         2           getdents</div><div class="line">  0.00    0.000000           0         1           getrlimit</div><div class="line">  0.00    0.000000           0         1           futex</div><div class="line">  0.00    0.000000           0         1           set_tid_address</div><div class="line">  0.00    0.000000           0         1           openat</div><div class="line">  0.00    0.000000           0         1           set_robust_list</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">100.00    0.001927                   116         1 total</div></pre></td></tr></table></figure>
<h3 id="5-保存输出结果"><a href="#5-保存输出结果" class="headerlink" title="5.保存输出结果"></a>5.保存输出结果</h3><p>为了保存strace的输出内容，专门提供了“-o”选项，其实上面已经使用过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o $&#123;filename&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-显示时间戳"><a href="#6-显示时间戳" class="headerlink" title="6.显示时间戳"></a>6.显示时间戳</h3><p>有时为了精确定位 每个系统调用的时间信息，可以通过”-t”选项可以在每行前面添加时间了。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# strace -t ls</div><div class="line">06:14:53 execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], [/* 46 vars */]) = 0</div><div class="line">06:14:53 brk(0)                         = 0x18ef000</div><div class="line">06:14:53 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7c9683e000</div><div class="line">06:14:53 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)</div><div class="line">06:14:53 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">06:14:53 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=149730, ...&#125;) = 0</div><div class="line">06:14:53 mmap(NULL, 149730, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7c96819000</div><div class="line">06:14:53 close(3)                       = 0</div></pre></td></tr></table></figure>
<h4 id="1-显示更精细的时间"><a href="#1-显示更精细的时间" class="headerlink" title="1) 显示更精细的时间"></a>1) 显示更精细的时间</h4><p>为了更精确的时间信息，strace也为大家提前想到了，那就是”-tt“</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# strace -tt ls</div><div class="line">06:16:08.394829 execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], [/* 46 vars */]) = 0</div><div class="line">06:16:08.396626 brk(0)                  = 0x2174000</div><div class="line">06:16:08.396775 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f192247c000</div><div class="line">06:16:08.396838 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)</div><div class="line">06:16:08.396963 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">06:16:08.397052 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=149730, ...&#125;) = 0</div><div class="line">06:16:08.397104 mmap(NULL, 149730, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1922457000</div><div class="line">06:16:08.397149 close(3)                = 0</div></pre></td></tr></table></figure>
<p>注：如果还想要更精细的，也可以满足，那就是在原选项上再加”t” ,即”-ttt”.</p>
<h4 id="2-显示相对时间"><a href="#2-显示相对时间" class="headerlink" title="2) 显示相对时间"></a>2) 显示相对时间</h4><p>有时需要每个系统调用的相对 时间，免去自己进行时间去处，直接通过”-r”选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# strace -r ls</div><div class="line">     0.000000 execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], [/* 46 vars */]) = 0</div><div class="line">     0.000459 brk(0)                    = 0x1312000</div><div class="line">     0.000056 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fda2314a000</div><div class="line">     0.000050 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)</div><div class="line">     0.000083 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">     0.000040 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=149730, ...&#125;) = 0</div><div class="line">     0.000028 mmap(NULL, 149730, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fda23125000</div><div class="line">     0.000022 close(3)                  = 0</div></pre></td></tr></table></figure>
<h3 id="7-跟踪发送给进程的信号"><a href="#7-跟踪发送给进程的信号" class="headerlink" title="7.跟踪发送给进程的信号"></a>7.跟踪发送给进程的信号</h3><p>这里以samba服务进程被kill的过程为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ps -ef|grep smb</div><div class="line">root       4123      1  0 16:39 ?        00:00:00 /usr/sbin/smbd</div><div class="line">root       4124   4123  0 16:39 ?        00:00:00 /usr/sbin/smbd</div><div class="line">root       4125   4123  0 16:39 ?        00:00:00 /usr/sbin/smbd</div><div class="line">root       4126   4123  0 16:39 ?        00:00:00 /usr/sbin/smbd</div><div class="line">root       4134   3770  0 16:39 pts/0    00:00:00 grep --color=auto smb</div><div class="line">[root@localhost ~]# strace -o smb.log -p 4123 &amp;</div><div class="line">[1] 4139</div><div class="line">[root@localhost ~]# Process 4123 attached</div><div class="line"></div><div class="line">[root@localhost ~]# kill -9 4123</div><div class="line">[1]+  \u5b8c\u6210                  strace -o smb.log -p 4123</div><div class="line">[root@localhost ~]# cat smb.log </div><div class="line">restart_syscall(&lt;... resuming interrupted call ...&gt; &lt;unfinished ...&gt;</div><div class="line">+++ killed by SIGKILL +++</div></pre></td></tr></table></figure>
<p>最后一行”+++ killed by SIGKILL +++”就可以看出该进程收到的信号是SIGKILL</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>主要利用ptrace系统调用来实现的。另外 ，GDB也同样是通过pstrace实现的，它是调试器的核心。这里简单说明一下ptrace的调用过程：<br>通过ptrace系统调用可以让一个进程控制另一个进程，两个进程之间通过信号来实现交互。<br>由于ptrace功能强大而复杂，后面以专门的篇幅来说明，这里只是蜻蜓点水一下。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="1-诊断软件的疑难杂症"><a href="#1-诊断软件的疑难杂症" class="headerlink" title="1.诊断软件的疑难杂症"></a>1.诊断软件的疑难杂症</h2><p>面对一个奇怪的问题，特别是一时无从下手的时候，更是要整理思绪，想办法获取线索，和刑警破案是一样的，需要各路寻访，借助各种监控设备，寻找蛛丝马迹。同样，strace就是寻找线索最简捷的工具了。</p>
<h2 id="2-掌握一个软件的运行原理"><a href="#2-掌握一个软件的运行原理" class="headerlink" title="2.掌握一个软件的运行原理"></a>2.掌握一个软件的运行原理</h2><p>用调试工具实时跟踪软件的运行情况不仅是诊断软件”疑难杂症”的有效的手段，也可帮助我们理清软件的”脉络”，即快速掌握软件的运行流程和工作原理，不失为一种学习源代码的辅助方法。</p>
<p>注：这种也是以运行结果为导向，逆向去了解源码<br>当然，通过strace查看其运行过程，信息往往是杂乱无章的，这时就需要根据这些信息进一步加工，自己整理出软件的运行原理过程</p>
<h2 id="3-分析网络连接问题"><a href="#3-分析网络连接问题" class="headerlink" title="3.分析网络连接问题"></a>3.分析网络连接问题</h2><p>分析网络比较常用的tcpdump,但有些情况下，使用strace则更能方便快捷地看到运行过程。这里其实就是将网络进程当作普通进程一样来跟踪了。</p>
<h2 id="4-分析数据执行SQL的情况"><a href="#4-分析数据执行SQL的情况" class="headerlink" title="4.分析数据执行SQL的情况"></a>4.分析数据执行SQL的情况</h2><p>这里主要是为了说明strace的强大和灵活应用，数据库同样也是一个进程，是进程就可以被strace,为此，我们在系统里启动一个sqlite进程，并在另一个终端里跟踪它，最终得到的日志 里便 可看到该 进程所执行过的SQL语句了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket(PF_NETLINK, SOCK_RAW, 9)         = 4</div><div class="line">sendmsg(4, &#123;msg_name(12)=&#123;sa_family=AF_NETLINK, pid=0, groups=00000000&#125;, msg_iov(2)=[&#123;&quot;&amp;\0\0\0d\4\1\0\0\0\0\0\0\0\0\0&quot;, 16&#125;, &#123;&quot;select * from test\0&quot;, 22&#125;], msg_controllen=0, msg_flags=0&#125;, 0) = 38</div><div class="line">close(4)</div></pre></td></tr></table></figure>
<h2 id="5-性能分析"><a href="#5-性能分析" class="headerlink" title="5.性能分析"></a>5.性能分析</h2><p>说起性能分析，问题比较大，面也比较广，其实在Linux平台上有很多工具，这里使用一张别人的一个图来见识一下：<br><img src="http://on44nkxjb.bkt.clouddn.com/17-3-30/41104682-file_1490852686279_d7c0.png" alt="image"></p>
<p>当然，利用strace的独特角度和统计功能，就可能会找到一个程序的运行瓶颈。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://linux.cn/article-3935-1.html" target="_blank" rel="external">https://linux.cn/article-3935-1.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-tsl/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-tsl/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向的读者&quot;&gt;&lt;a href=&quot;#面向的读者&quot; class=&quot;headerlink&quot; title=&quot;面向的读者&quot;&gt;&lt;/a&gt;面向的读者&lt;/h1&gt;&lt;p&gt;此篇面向经常需要解决Linux平台上程序的疑难杂症的读者，通过此篇可以掌握strace的常见用法，全面了解strac
    
    </summary>
    
      <category term="调试工具" scheme="http://linuxsir.top/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="strace" scheme="http://linuxsir.top/tags/strace/"/>
    
      <category term="性能分析" scheme="http://linuxsir.top/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
      <category term="调试" scheme="http://linuxsir.top/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>独立博客开章啦</title>
    <link href="http://linuxsir.top/2016/02/20/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AB%A0%E5%95%A6/"/>
    <id>http://linuxsir.top/2016/02/20/独立博客开章啦/</id>
    <published>2016-02-20T14:16:36.000Z</published>
    <updated>2016-01-31T12:44:33.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从业多年，一直没有认真对待写技术博客这件事情，从现在开始要重视这件事情了，原因有三：</p>
<ol>
<li>博客是对自己技术经历的完整记录</li>
<li>将自己的经历分享出来，做为看别人博客的回报</li>
<li>帮助自己总结经验，梳理经验，提取精华，以便应用到更广的领域里去。</li>
<li>博客是自己最专业的简历</li>
</ol>
<h1 id="博客计划"><a href="#博客计划" class="headerlink" title="博客计划"></a>博客计划</h1><ul>
<li>每周至少一篇</li>
<li>记录在工作中，学习中遇到的新玩意，透过现象看本质，透过功能看原理，提取有用的精华，融入到自己的知识体系中</li>
<li>既要注重理论的总结，也要注重实践。</li>
</ul>
<h1 id="博客的框架"><a href="#博客的框架" class="headerlink" title="博客的框架"></a>博客的框架</h1><h3 id="面向的读者类型"><a href="#面向的读者类型" class="headerlink" title="面向的读者类型"></a>面向的读者类型</h3><h3 id="明确文章的目标"><a href="#明确文章的目标" class="headerlink" title="明确文章的目标"></a>明确文章的目标</h3><h3 id="实践的步骤"><a href="#实践的步骤" class="headerlink" title="实践的步骤"></a>实践的步骤</h3><h3 id="实践背后的理论"><a href="#实践背后的理论" class="headerlink" title="实践背后的理论"></a>实践背后的理论</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p> 不断地思考，不断地实践，不断地完善自己的知识体系，形成自己的能量小宇宙。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从业多年，一直没有认真对待写技术博客这件事情，从现在开始要重视这件事情了，原因有三：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;博客是对自己技术经历的完整记
    
    </summary>
    
      <category term="心路历程" scheme="http://linuxsir.top/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="http://linuxsir.top/2016/01/19/about/"/>
    <id>http://linuxsir.top/2016/01/19/about/</id>
    <published>2016-01-19T11:19:20.000Z</published>
    <updated>2017-04-09T10:25:44.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://on44nkxjb.bkt.clouddn.com/17-4-7/75648830-file_1491530145271_e710.png" alt="image"></p>
<h1 id="自我简介"><a href="#自我简介" class="headerlink" title="自我简介"></a>自我简介</h1><p>从业多年的码农一枚，在网络上ID为linuxsir , 对Linux系统颇有感情，以Linux君为挚友，相伴十年有余，很了解Linux君的品性，注定它会成为我一生的伙伴，相信它也会给我带来美好的未来！<br>致力于从茫茫知识海洋里，组建自己的知识体系，能够不断冲破繁杂的现实问题，达到成功的彼岸！</p>
<h1 id="感兴趣的领域"><a href="#感兴趣的领域" class="headerlink" title="感兴趣的领域"></a>感兴趣的领域</h1><ul>
<li>Linux内核原理</li>
<li>信息安全</li>
<li>网络安全</li>
<li>Linux安全体系</li>
<li>Python</li>
<li>虚拟化</li>
</ul>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>Email： linux.sir@qq.com<br>GitHub: <a href="https://github.com/linux-sir" target="_blank" rel="external">https://github.com/linux-sir</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://on44nkxjb.bkt.clouddn.com/17-4-7/75648830-file_1491530145271_e710.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;自我简介&quot;&gt;&lt;a href=&quot;#自我简介&quot; cl
    
    </summary>
    
    
  </entry>
  
</feed>
